# 每日面试题之会一道身价涨五块

## 1.每个HTML文件里面都有一个很重要的东西，Doctype，知道这是干什么的么？



答：<!DOCTYPE>声明位于文档中最前面的位置，处于标签之前。此标签可告知浏览器文档使用哪种HTML或XHTML规范。（重点：告诉浏览器按照何种规范解析页面）

## 2.常用浏览器有哪些，内核都是什么？



**答：** 常用浏览器有chrome、safari、 IE、火狐(firefox) 、 Opera 、360、搜狗等

| 浏览器  | 内核           | 备注                                                         |
| ------- | -------------- | ------------------------------------------------------------ |
| IE      | Trident        | IE、猎豹安全、360极速浏览器、百度浏览器                      |
| firefox | Gecko          | 可惜这几年已经没落了，打开速度慢、升级频繁、猪一样的队友flash、神一样的对手chrome。 |
| Safari  | webkit         | 现在很多人错误地把 webkit 叫做 chrome内核（即使 chrome内核已经是 blink 了）。苹果感觉像被别人抢了媳妇，都哭晕再厕所里面了。 |
| chrome  | Chromium/Blink | 在 Chromium 项目中研发 Blink 渲染引擎（即浏览器核心），内置于 Chrome 浏览器之中。Blink 其实是 WebKit 的分支。大部分国产浏览器最新版都采用Blink内核。二次开发 |
| Opera   | blink          | Presto（已经废弃） 是挪威产浏览器 opera 的 “前任” 内核,现在跟随chrome用blink内核。 |



## 3.简述一下你对HTML语义化的理解？



1. 去掉或丢失样式的时候能够让页面呈现出清晰的结构。
2. 有利于SEO和搜索引擎建立良好沟通，有助于爬虫抓取更多的信息，爬虫依赖于标签来确定上下文和各个关键字的权重。

1. 方便其它设备解析。
2. 便于团队开发和维护，语义化根据可读性。

## 4.HTML5有哪些新特性,移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分HTML和HTML5？



答：新增加了图像、位置、存储、多任务等功能。

新增元素：

1. canvas
2. 用于媒介回放的video和audio元素

1. 本地离线存储。localStorage长期存储数据，浏览器关闭后数据不丢失;sessionStorage的数据在浏览器关闭后自动删除
2. 语意化更好的内容元素，比如 article footer header nav section

1. 位置API：Geolocation
2. 表单控件，calendar date time email url search

1. 新的技术：web worker(web worker是运行在后台的 JavaScript，独立于其他脚本，不会影响页面的性能。您可以继续做任何愿意做的事情：点击、选取内容等等，而此时 web worker 在后台运行) web socket
2. 拖放API：drag、drop

移除的元素：

1. 纯表现的元素：basefont big center font s strike tt u
2. 性能较差元素：frame frameset noframes

区分：

1. DOCTYPE声明的方式是区分重要因素
2. 根据新增加的结构、功能来区分



## 5.页面导入样式时，使用link和@import有什么区别？



**1.从属关系区别**

@import是 CSS 提供的语法规则，只有导入样式表的作用；link是HTML提供的标签，不仅可以加载 CSS 文件，还可以定义 RSS、rel 连接属性等。



**2.加载顺序区别**

加载页面时，link标签引入的 CSS 被同时加载；@import引入的 CSS 将在页面加载完毕后被加载。



**3.兼容性区别**

@import是 CSS2.1 才有的语法，故只可在 IE5+ 才能识别；link标签作为 HTML 元素，不存在兼容性问题。



**4.DOM可控性区别**

可以通过 JS 操作 DOM ，插入link标签来改变样式；由于 DOM 方法是基于文档的，无法使用@import的方式插入样式。



**5.权重区别(该项有争议，下文将详解)**

link引入的样式权重大于@import引入的样式。

## 6.position属性和值的含义

position 属性规定元素的定位类型。

| 值       | 描述                                                         |
| -------- | ------------------------------------------------------------ |
| absolute | 生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。元素的位置通过 "left", "top", "right" 以及 "bottom" 属性进行规定。 |
| fixed    | 生成绝对定位的元素，相对于浏览器窗口进行定位。元素的位置通过 "left", "top", "right" 以及 "bottom" 属性进行规定。 |
| relative | 生成相对定位的元素，相对于其正常位置进行定位。因此，"left:20" 会向元素的 LEFT 位置添加 20 像素。 |
| static   | 默认值。没有定位，元素出现在正常的流中                       |



## 7.null，undefined的区别？



- Undefined类型只有一个值，即undefined。当声明的变量还未被初始化时，变量的默认值为undefined。
- Null类型也只有一个值，即null。

- null是javascript的关键字，可以认为是对象类型，它是一个空对象指针，和其他语言一样都代表“空值”，不过undefined却是javascript才有的。undefined是在ECMAScript第三版引入的，为了区分指针对象和未初始化的变量，它是一个预定义的全局变量。没有返回值的函数返回为undefined，没有实参的形参也是undefined。
- javascript权威指南：null 和 undefined 都表示 “值的空缺”，你可以认为 undefined 是表示系统级的、出乎意料的或类似错误的值的空缺，而null是表示程序级的、正常的或在意料之中的值的空缺。

- javascript高级程序设计：在使用var声明变量但未对其加以初始化时，这个变量的值就是undefined。null值则是表示空对象指针。





## 8.说出你熟悉的数组操作方法

``//改变原数组方法:
var arr = []
arr.push()  //数组末尾添加
arr.pop() 	//数组末尾删除
arr.unshift()  //数组头部添加
arr.shift()			//数组头部删除
arr.splice()		//方法向/从数组中添加/删除项目，然后返回被删除的项目。
arr.reverse()		//方法用于颠倒数组中元素的顺序。
arr.sort()			//方法用于对数组的元素进行排序。
//不改变原数组方法:
var arr = []
arr.includes();  // 方法用于判断字符串是否包含指定的子字符串。如果找到匹配的字符串则返回 true，否则返回 false。
arr.indexOf();		//方法可返回某个指定的字符串值在字符串中首次出现的位置。
arr.lastIndexOf();	//方法可返回一个指定的字符串值最后出现的位置，在一个字符串中的指定位置从后向前搜索。
arr.slice();			//方法可从已有的数组中返回选定的元素。
arr.join();				//方法用于把数组中的所有元素放入一个字符串。元素是通过指定的分隔符进行分隔的。
arr.toString();	
arr.concat();		//方法用于连接两个或多个数组。



//高阶js新增数组方法

arr.forEach//遍历数组



//数组方法filter过滤数组
filter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。



//数组方法some
arr.some()// 查找数组中是否有满足条件的元素 ,如果数组中有元素满足条件返回 true，否则返回 false。



//数组方法every
every() 方法用于检测数组所有元素是否都符合指定条件（通过函数提供）。
every() 方法使用指定函数检测数组中的所有元素：
array.every(function(currentValue,index,arr))



- 如果数组中检测到有一个元素不满足，则整个表达式返回 false ，且剩余的元素不会再进行检测。
- 如果所有元素都满足条件，则返回 true。
  注意： every() 不会对空数组进行检测。
  注意： every() 不会改变原始数组。



//数组方法find
find() 方法返回通过测试（函数内判断）的数组的第一个元素的值。
find() 方法为数组中的每个元素都调用一次函数执行：



- 当数组中的元素在测试条件时返回 true 时, find() 返回符合条件的元素，之后的值不会再调用执行函数。
- 如果没有符合条件的元素返回 undefined





## 9.如何编写高性能的JavaScript

- 将js脚本放在页面底部，加快渲染页面;
- 将js脚本成组打包，减少请求;

- 使用非阻塞方式下载js脚本;
- 尽量使用局部变量来保存全局变量;

- 尽量减少使用闭包;
- 使用window对象属性方法时省略window;

- 尽量减少对象成员嵌套;
- 缓存DOM节点的访问;

- 通过避免使用eval和function()构造器;
- 给setTimeout()和setInterval()传递函数而不是字符作为参数;

- 尽量使用直接量创建对象和数组;
- 最小化重绘(repaint)和回流(reflow);



## 10.标准盒模型 和ie盒模型区别(复习CSS知识等)

标准盒模型是w3c 标准的盒模型，其包含：

盒子占用宽度：margin + border+ padding + width

实际宽度： border+ padding + width

IE盒模型，在IE中content的宽度包括padding和border这两个属性，所以

盒子占用宽度：margin + width

实际宽度：width = padding + border + **内容宽度**





## 11.栈结构和队列结构,这两种数据结构的区别?



栈的插入和删除操作都是在一端进行的，而队列的操作却是在两端进行的。

队列先进先出，栈先进后出。

栈只允许在表尾一端进行插入和删除，而队列只允许在表尾一端进行插入，在表头一端进行删除

## 12.栈区和堆区的区别？



一、 堆(heap)和栈(stack)

栈(stack)会自动分配内存空间，会自动释放。堆(heap)动态分配的内存，大小不定也不会自动释放。

二、 基本类型和引用类型

基本类型：简单的数据段，存放在栈内存中，占据固定大小的空间。

引用类型：指那些可能由多个值构成的对象，保存在堆内存中,包含引用类型的变量实际上保存的不是变量本身，二十指向该对象的指针。

基本数据类型包括Undefined,String,Boolean,Null,Number

三、 传值和传址

从一个向另一个变量复制引用类型的值，复制的其实是指针，因此两个变量最终指向同一个对象。即复制的是栈中的地址而不是堆中的对象。

从一个变量复向另一个变量复制基本类型的值，会创建这个值的副本。







## 13.什么是作用域和作用域链，请解释一下？



**作用域（scope）**



在 Javascript 中，作用域分为 **全局作用域** 和 **局部作用域**

全局作用域:代码在程序的任何地方都能被访问，window 对象的内置属性都拥有全局作用域。

局部作用域:在固定的代码片段才能被访问。



**作用域链（scope chain）**



在当前作用域中没有查到值，就会向上级作用域去查，直到查到全局作用域，这么一个查找过程形成的链条就叫做作用域链。





## 14.作用域链



- 只有函数可以制造作用域结构， 那么只要是代码，就至少有一个作用域, 即全局作用域。凡是代码中有函数，那么这个函数就构成另一个作用域。如果函数中还有函数，那么在这个作用域中就又可以诞生一个作用域。



- 将这样的所有的作用域列出来，可以有一个结构:在当前作用域中没有查到值，就会向上级作用域去查，直到查到全局作用域，这么一个查找过程形成的链条就叫做作用域链。



- 作用域链：采取就近原则的方式来查找变量最终的值。



## 15.函数声明与函数表达式的区别？

在Javscript中，解析器在向执行环境中加载数据时，对函数声明和函数表达式并非是一视同仁的，解析器会率先读取函数声明，并使其在执行任何代码之前可用（可以访问），至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解析执行。







## 16.new操作符具体干了什么呢?

1. 创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。
2. 属性和方法被加入到 this 引用的对象中。

1. 新创建的对象由 this 所引用，并且最后隐式的返回 this 。





## 17.请说出至少三种减低页面加载时间的方法？

1. 压缩css、js文件
2. 合并js、css文件，减少http请求

1. 外部js、css文件放在最底下
2. 减少dom操作，尽可能用变量替代不必要的dom操作





## 18.说一下你对this的理解？ 

this 的指向，是当我们调用函数的时候确定的。调用方式的不同决定了this 的指向不同



1. 普通函数this在非严格模式下指向window，严格模式下指向undefined
2. 构造函数this指向实例对象，原型对象里面的方法也指向实例对象

1. 对象方法中的this指向该方法所属的对象
2. 事件绑定方法中的this指向绑定该事件的对象

1. 定时器函数的this指向window
2. 立即执行函数中的this指向window





## 19.全局变量和局部变量的区别？ 



变量根据作用域的不同分为两种：全局变量和局部变量。



1. 函数内部可以使用全局变量。
2. 函数外部不可以使用局部变量。

1. 当函数执行完毕，本作用域内的局部变量会销毁。
2. 网页关闭时,全局变量销毁。





## 20.简单数据类型和复杂数据类型

简单类型（基本数据类型、值类型）：在存储时变量中存储的是值本身，包括String ，Number，Boolean，Undefined，Null

复杂数据类型（引用类型）：在存储时变量中存储的仅仅是地址（引用），通过 new 关键字创建的对象（系统对象、自定义对象），如 Object、Array、Date等；







## 21.总结String 对象操作方法

| 方法           | 描述                                                         |
| -------------- | ------------------------------------------------------------ |
| charAt()       | 返回在指定位置的字符。                                       |
| charCodeAt()   | 返回在指定的位置的字符的 Unicode 编码。                      |
| concat()       | 连接两个或更多字符串，并返回新的字符串。                     |
| fromCharCode() | 将 Unicode 编码转为字符。                                    |
| indexOf()      | 返回某个指定的字符串值在字符串中首次出现的位置。             |
| includes()     | 查找字符串中是否包含指定的子字符串。                         |
| lastIndexOf()  | 从后向前搜索字符串，并从起始位置（0）开始计算返回字符串最后出现的位置。 |
| search()       | 查找与正则表达式相匹配的值。                                 |
| slice()        | 提取字符串的片断，并在新的字符串中返回被提取的部分。不包含结束的索引 |
| split()        | 把字符串分割为字符串数组。                                   |
| substr()       | 从起始索引号提取字符串中指定数目的字符。                     |
| substring()    | 提取字符串中两个指定的索引号之间的字符。                     |
| toLowerCase()  | 把字符串转换为小写。                                         |
| toUpperCase()  | 把字符串转换为大写。                                         |
| trim()         | 去除字符串两边的空白                                         |
| toString()     | 返回一个字符串。                                             |



## 22.”==”和“===”的不同

答案：前者会自动转换类型,再判断是否相等

后者不会自动类型转换，直接去比较





## 23.javascript的typeof返回哪些数据类型.

答案：string,boolean,number,undefined,function,object





## 24说说写JavaScript的基本规范？

1) 不要在同一行声明多个变量

2) 使用 ===或!==来比较true/false或者数值

3) switch必须带有default分支

4) 函数应该有返回值

5) for if else 必须使用大括号

6) 语句结束加分号

7) 命名要有意义，使用驼峰命名法









## 25.DOM 事件流是什么?如何阻止事件冒泡？



- **事件流**：从页面中接收事件的顺序。也就是说当一个事件产生时，这个事件的传播过程，就是事件流。
  事件流包括三个阶段事件捕获,目标阶段,事件冒泡。
- **事件捕获**：它认为当某个事件发生时，从window发出一个事件，不断经过下级节点最终到达目标节点之前的阶段。（当某个事件发生时，父元素最先捕获到事件，目标元素最后收到）

- **目标阶段**：当事件不断传递直到目标节点的时候，最终在目标节点上出发这个事件。
- **事件冒泡**：事件冒泡即事件开始时，由最具体的元素接收（也就是事件发生所在的节点），然后层层往上传递，直至传递到dom的根节点。

- 阻止事件冒泡:event.stopPropagation()



## 26.什么是事件委托?



利用事件冒泡的原理，原本绑定在子元素身上的事件，现在绑定在父元素身上，由父元素监听事件的行为。



## 27.BOM 和 DOM 的关系



BOM全称Browser Object Model，即浏览器对象模型，主要处理浏览器窗口和框架。



DOM全称Document Object Model，即文档对象模型，是 HTML 和XML 的应用程序接口（API），遵循W3C 的标准，所有浏览器公共遵守的标准。



JS是通过访问BOM（Browser Object Model）对象来访问、控制、修改客户端(浏览器)，由于BOM的window包含了document，window对象的属性和方法是直接可以使用而且被感知的，因此可以直接使用window对象的document属性，通过document属性就可以访问、检索、修改XHTML文档内容与结构。因为document对象又是DOM的根节点。



可以说，BOM包含了DOM(对象)，浏览器提供出来给予访问的是BOM对象，从BOM对象再访问到DOM对象，从而js可以操作浏览器以及浏览器读取到的文档。



## 



## 28.href与src的区别(只背重点)



1.href：Hypertext Reference的缩写，超文本引用，它指向一些网络资源，建立和当前元素或者说是本文档的链接关系。在加载它的时候，不会停止对当前文档的处理，浏览器会继续往下走。常用在a、link等标签。



2.src：source的所写，表示的是对资源的引用，它指向的内容会嵌入到当前标签所在的位置。由于src的内容是页面必不可少的一部分，因此浏览器在解析src时会停下来对后续文档的处理，直到src的内容加载完毕。常用在script、img、iframe标签中，我们建议js文件放在HTML文档的最后面。如果js文件放在了head标签中，可以使用window.onload实现js的最后加载。



总结：href用于建立当前页面与引用资源之间的关系（链接），而src则会替换当前标签。遇到href，页面会并行加载后续内容；而src则不同，浏览器需要加载完毕src的内容才会继续往下走。







## 29.说一说事件代理,优缺点是什么?



事件代理是指将事件绑定到目标元素的父元素上,利用冒泡机制触发该事件

优点:

1.可以减少事件注册,节省大量内存占用

2.可以将事件应用于动态添加的子元素上

缺点:

使用不当会造成事件在不应该触发时触发





## 30.setTimeout 和 setInterval 细谈

常问的点，前者是在一定时间过后将函数添加至执行队列，执行时间=延迟时间+之前函数代码执行时间+执行函数时间。

后者是不管前一次是否执行完毕，每隔一定时间重复执行，用于精准执行互相没有影响的重复操作。

如果需要控制前后执行顺序，最好使用setTimeout模拟setInterval





## 31.DOM操作中，如何获取元素的属性值？ 

1、 element.attributes[下标].value
2、 element.attributes['属性名'].value
3、 element.getAttributeNode('属性名').value
4、 element.getAttribute('属性名')





## 32.在DOM中操作中怎么创建、添加、删除、移除、替换、插入和查找节点



①通过以下代码创建节点

createDocumentFragment()*//创建一个DOM片段*

createElement();*//创建一个具体的元素*

createTextNode();*//创建一个文本节点*



②添加、移除、替换、插入节点

appendChild();

removeChild();

replaceChild();

insertBefore();



③通过以下方式查找节点

getElementById();

getElementsByTagName();

getElementsByName();







## 33.H5新特性:

1. 拖拽释放(Drag and drop) API
2. 语义化更好的内容标签（header,nav,footer,aside,article,section）

1. 音频、视频API(audio,video)
2. 画布(Canvas) API

1. 地理(Geolocation) API
2. 数据存储 localStorage、sessionStorage

1. 表单控件date、time、email、url、search





## 34.HTML5有哪些新特性,移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分HTML和HTML5？



答：新增加了图像、位置、存储、多任务等功能。

新增元素：

1. canvas
2. 用于媒介回放的video和audio元素

1. 本地离线存储。localStorage长期存储数据，浏览器关闭后数据不丢失;sessionStorage的数据在浏览器关闭后自动删除
2. 语意化更好的内容元素，比如 article footer header nav section

1. 位置API：Geolocation
2. 表单控件，calendar date time email url search

1. 新的技术：web worker(web worker是运行在后台的 JavaScript，独立于其他脚本，不会影响页面的性能。您可以继续做任何愿意做的事情：点击、选取内容等等，而此时 web worker 在后台运行) web socket
2. 拖放API：drag、drop

移除的元素：

1. 纯表现的元素：basefont big center font s strike tt u
2. 性能较差元素：frame frameset noframes

区分：

1. DOCTYPE声明的方式是区分重要因素
2. 根据新增加的结构、功能来区分

## 





## 35.你用过媒体查询，或针对移动端的布局/CSS吗？

媒体查询，就是响应式布局。通过不同的媒介类型和条件定义样式表规则。媒介查询让CSS可以更精确作用于不同的媒介类型和同一媒介的不同条件。



语法结构及用法：[@media](https://www.yuque.com/media) 设备名 only （选取条件） not （选取条件） and（设备选取条件）。 





## 36.CSS3新特性：

1. 颜色：新增RGBA，HSLA模式
2. 文字阴影（text-shadow）

1. 边框： 圆角（border-radius）边框阴影： box-shadow
2. 盒子模型：box-sizing

1. 背景：background-size 设置背景图片的尺寸background-origin 设置背景图片的原点background-clip 设置背景图片的裁切区域，以”，”分隔可以设置多背景，用于自适应布局
2. 渐变：linear-gradient、radial-gradient

1. 过渡：transition，可实现动画
2. 自定义动画

1. 在CSS3中唯一引入的伪元素 ：selection.
2. 媒体查询，多栏布局

1. border-image
2. 2D转换：transform：translate(x，y) rotate(x，y) skew(x，y) scale(x，y)

1. 3D转换

14.新增选择器：属性选择器、伪类选择器、伪元素选择器。





## 37.什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？



响应式网站设计(Responsive Web design)是一个网站能够兼容多个终端，而不是为每一个终端做一个特定的版本。

基本原理是通过媒体查询检测不同的设备屏幕尺寸做处理。

页面头部必须有meta声明的viewport。





## 38.::before 和 :after中双冒号和单冒号有什么区别？解释一下这2个伪元素的作用



单冒号(:)用于CSS3伪类，双冒号(::)用于CSS3伪元素。



::before就是以一个子元素的存在，定义在元素主体内容之前的一个伪元素。并不存在于dom之中，只存在在页面之中。





## 39.flex属性举例说明

## **父元素属性**

1.display:flex;（定义了一个flex容器）

2.flex-direction（决定主轴的方向）

row（默认值，水平从左到右）colunm（垂直从上到下）row-reverse（水平从右到左）column-reverse（垂直从下到上）

3.flex-wrap（定义如何换行）

nowrap（默认值，不换行）wrap（换行）wrap-reverse（换行，且颠倒行顺序，第一行在下方）

4.flex-flow（属性是 flex-direction 属性和 flex-wrap 属性的简写形式，默认值为row nowrap）

5.justify-content（设置或检索弹性盒子元素在主轴（横轴）方向上的对齐方式）

flex-start（ 默认值、弹性盒子元素将向行起始位置对齐）

flex-end（弹性盒子元素将向行结束位置对齐）

center（弹性盒子元素将向行中间位置对齐。该行的子元素将相互对齐并在行中居中对齐）

space-between（弹性盒子元素会平均地分布在行里）

space-around（弹性盒子元素会平均地分布在行里，两端保留子元素与子元素之间间距大小的一半）

6.align-items（设置或检索弹性盒子元素在侧轴（纵轴）方向上的对齐方式）

flex-start（弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴起始边界）

flex-end（弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴结束边界）

center（ 弹性盒子元素在该行的侧轴（纵轴）上居中放置。（如果该行的尺寸小于弹性盒子元素的尺寸，则会向两个方向溢出相同的长度））

baseline（如弹性盒子元素的行内轴与侧轴为同一条，则该值与flex-start等效。其它情况下，该值将参与基线对齐。）

stretch（如果指定侧轴大小的属性值为'auto'，则其值会使项目的边距盒的尺寸尽可能接近所在行的尺寸，但同时会遵照'min/max-width/height'属性的限制）

7.align-content（设置或检索弹性盒堆叠伸缩行的对齐方式）

flex-start（各行向弹性盒容器的起始位置堆叠。弹性盒容器中第一行的侧轴起始边界紧靠住该弹性盒容器的侧轴起始边界，之后的每一行都紧靠住前面一行）

flex-end（各行向弹性盒容器的结束位置堆叠。弹性盒容器中最后一行的侧轴起结束界紧靠住该弹性盒容器的侧轴结束边界，之后的每一行都紧靠住前面一行）

center（各行向弹性盒容器的中间位置堆叠。各行两两紧靠住同时在弹性盒容器中居中对齐，保持弹性盒容器的侧轴起始内容边界和第一行之间的距离与该容器的侧轴结束内容边界与第最后一 行之间的距离相等）

space-between（各行在弹性盒容器中平均分布。第一行的侧轴起始边界紧靠住弹性盒容器的侧轴起始内容边界，最后一行的侧轴结束边界紧靠住弹性盒容器的侧轴结束内容边界，剩余的行则 按一定方式在弹性盒窗口中排列，以保持两两之间的空间相等）

space-around（ 各行在弹性盒容器中平均分布，两端保留子元素与子元素之间间距大小的一半。各行会按一定方式在弹性盒容器中排列，以保持两两之间的空间相等，同时第一行前面及最后 一行后面的空间是其他空间的一半）

stretch（各行将会伸展以占用剩余的空间。剩余空间被所有行平分，以扩大它们的侧轴尺寸）

## **子元素上属性**

1.order（默认情况下flex order会按照书写顺训呈现，可以通过order属性改变，数值小的在前面，还可以是负数）

2.flex-grow（设置或检索弹性盒的扩展比率,根据弹性盒子元素所设置的扩展因子作为比率来分配剩余空间）

3.flex-shrink（设置或检索弹性盒的收缩比率,根据弹性盒子元素所设置的收缩因子作为比率来收缩空间）

4.flex-basis (设置或检索弹性盒伸缩基准值，如果所有子元素的基准值之和大于剩余空间，则会根据每项设置的基准值，按比率伸缩剩余空间)

5.flex (flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选)


//flex属性意义
flex:none;  // flex:0,0,auto;
flex:auto;  // flex:1,1,auto;
flex:1;   //  flex:1,1,0%;

6.align-self (设置或检索弹性盒子元素在侧轴（纵轴）方向上的对齐方式，可以覆盖父容器align-items的设置)

